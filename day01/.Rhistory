} else {
current = (current + df$num[i]) %% 100
}
positions[i] = current
}
df = df |>
mutate(
pos = positions,
is_zero = pos == 0
)
password = sum(df$is_zero)
password
df = tibble(x) |>
mutate(txt = gsub("[0-9]", "", x),
num = as.integer(gsub("[A-Za-z]", "", x)))
positions = numeric(nrow(df))
positions
df = tibble(x) |>
mutate(txt = gsub("[0-9]", "", x),
num = as.integer(gsub("[A-Za-z]", "", x)))
positions = numeric(nrow(df))
current = 50
for (i in seq_len(nrow(df))) {
if (df$txt[i] == "L") {
current = (current - df$num[i]) %% 100
} else {
current = (current + df$num[i]) %% 100
}
positions[i] = current
}
df = df |>
mutate(
pos = positions,
is_zero = pos == 0
)
password = sum(df$is_zero)
password
sum(df$is_zero)
df = tibble(x) |>
mutate(txt = gsub("[0-9]", "", x),
num = as.integer(gsub("[A-Za-z]", "", x)))
positions = numeric(nrow(df))
current = 50
for (i in seq_len(nrow(df))) {
if (df$txt[i] == "L") {
current = (current - df$num[i]) %% 100
} else {
current = (current + df$num[i]) %% 100
}
positions[i] = current
}
df = df |>
mutate(pos = positions,
is_zero = pos == 0)
sum(df$is_zero)
as.character(glue("Part 1 solution: {sum(df$is_zero)}"))
library(tidyverse)
library(glue)
x = readLines("input.txt")
df = tibble(x) |>
mutate(txt = gsub("[0-9]", "", x),
num = as.integer(gsub("[A-Za-z]", "", x)))
positions = numeric(nrow(df))
current = 50
for (i in seq_len(nrow(df))) {
if (df$txt[i] == "L") {
current = (current - df$num[i]) %% 100
} else {
current = (current + df$num[i]) %% 100
}
positions[i] = current
}
df = df |>
mutate(pos = positions,
is_zero = pos == 0)
as.character(glue("Part 1 solution: {sum(df$is_zero)}"))
total_zeros = 0
current = 50
for (i in seq_len(nrow(df))) {
direction = df$txt[i]
dist = df$num[i]
for (step in seq_len(dist)) {
if (direction == "L") {
current = (current - 1) %% 100
} else {
current = (current + 1) %% 100
}
if (current == 0) {
total_zeros = total_zeros + 1
}
}
}
total_zeros
seq_len
total_zeros = 0
current = 50
for (i in seq_len(nrow(df))) {
direction = df$txt[i]
dist = df$num[i]
for (step in seq_len(dist)) {
if (direction == "L") {
current = (current - 1) %% 100
} else {
current = (current + 1) %% 100
}
if (current == 0) {
total_zeros = total_zeros + 1
}
}
}
total_zeros
library(tidyverse)
library(glue)
x = readLines("input.txt")
df = tibble(x) |>
mutate(txt = gsub("[0-9]", "", x),
num = as.integer(gsub("[A-Za-z]", "", x)))
positions = numeric(nrow(df))
current = 50
for (i in seq_len(nrow(df))) {
if (df$txt[i] == "L") {
current = (current - df$num[i]) %% 100
} else {
current = (current + df$num[i]) %% 100
}
positions[i] = current
}
df = df |>
mutate(pos = positions,
is_zero = pos == 0)
as.character(glue("Part 1 solution: {sum(df$is_zero)}"))
total_zeros = 0
current = 50
for (i in seq_len(nrow(df))) {
direction = df$txt[i]
dist = df$num[i]
for (step in seq_len(dist)) {
if (direction == "L") {
current = (current - 1) %% 100
} else {
current = (current + 1) %% 100
}
if (current == 0) {
total_zeros = total_zeros + 1
}
}
}
total_zeros
total_zeros = 0
current = 50
for (i in seq_len(nrow(df))) {
direction = df$txt[i]
dist = df$num[i]
for (step in seq_len(dist)) {
if (direction == "L") {
current = (current - 1) %% 100
} else {
current = (current + 1) %% 100
}
if (current == 0) {
total_zeros = total_zeros + 1
}
}
}
as.character(glue("Part 1 solution: {total_zeros}"))
total_zeros = 0
current = 50
for (i in seq_len(nrow(df))) {
direction = df$txt[i]
dist = df$num[i]
for (step in seq_len(dist)) {
if (direction == "L") {
current = (current - 1) %% 100
} else {
current = (current + 1) %% 100
}
if (current == 0) {
total_zeros = total_zeros + 1
}
}
}
as.character(glue("Part 2 solution: {total_zeros}"))
setwd("~/r_projects/aoc25/day01")
readLines("input.txt")
library(tidyverse)
x = readLines("input.txt")
x
str_split(x, pattern = ",")
unlist(str_split(x, pattern = ","))
library(tidyverse)
x = unlist(str_split(readLines("input.txt"), pattern = ","))
x
tibble(x)
tibble(x) |>
separate(x, into = c("left", "right"), sep = "-", remove = F, convert = T)
library(tidyverse)
x = unlist(str_split(readLines("input.txt"), pattern = ","))
tibble(x) |>
separate(x, into = c("l", "r"), sep = "-", remove = F, convert = T)
library(tidyverse)
x = unlist(str_split(readLines("input.txt"), pattern = ","))
df = tibble(x) |>
separate(x, into = c("l", "r"), sep = "-", remove = F, convert = T)
df
# function to check if a number is two copies of the same sequence
is_invalid = function(n) {
s = as.character(n)
len = nchar(s)
if (len %% 2 != 0) {
return(FALSE)
}
half = len / 2
left = substr(s, 1, half)
right = substr(s, half + 1, len)
left == right
}
# generate all values per range, filter to invalid ones, sum
answer =
df |>
mutate(vals = map2(l, r, function(a, b) seq(a, b))) |>
mutate(invalid = map(vals, function(v) v[map_lgl(v, is_invalid)])) |>
pull(invalid) |>
unlist() |>
sum()
answer
library(tidyverse)
x = unlist(str_split(readLines("input.txt"), pattern = ","))
df = tibble(x) |>
separate(x, into = c("l", "r"), sep = "-", remove = FALSE, convert = TRUE)
# get max digits across all endpoints
max_digits = max(nchar(c(df$l, df$r)))
# generate all possible invalid numbers
# for each even length 2,4,6,...,max_digits
all_invalid =
map_dbl(seq(2, max_digits, by = 2), function(total_len) {
half_len = total_len / 2
start = 10^(half_len - 1)
end = (10^half_len) - 1
# generate patterns p, then paste p twice
patterns = start:end
as.numeric(paste0(patterns, patterns))
}) |>
unlist()
library(tidyverse)
library(glue)
x = unlist(str_split(readLines("input.txt"), pattern = ","))
df = tibble(x) |>
separate(x, into = c("l", "r"), sep = "-", remove = F, convert = T)
tictoc::tic()
is_invalid = function(n) {
s = as.character(n)
len = nchar(s)
if (len %% 2 != 0) {
return(F)
}
half = len / 2
left = substr(s, 1, half)
right = substr(s, half + 1, len)
left == right
}
answer = df |>
mutate(vals = map2(l, r, function(a, b) seq(a, b))) |>
mutate(invalid = map(vals, function(v) v[map_lgl(v, is_invalid)])) |>
pull(invalid) |>
unlist() |>
sum()
elapsed = tictoc::toc()
as.character(glue("Part 2 solution: {answer}; time elapsed = {elapsed}"))
library(tidyverse)
library(glue)
x = unlist(str_split(readLines("input.txt"), pattern = ","))
df = tibble(x) |>
separate(x, into = c("l", "r"), sep = "-", remove = F, convert = T)
df = slice_sample(df, n = 10)
tictoc::tic()
is_invalid = function(n) {
s = as.character(n)
len = nchar(s)
if (len %% 2 != 0) {
return(F)
}
half = len / 2
left = substr(s, 1, half)
right = substr(s, half + 1, len)
left == right
}
sol = df |>
mutate(vals = map2(l, r, function(a, b) seq(a, b))) |>
mutate(invalid = map(vals, function(v) v[map_lgl(v, is_invalid)])) |>
pull(invalid) |>
unlist() |>
sum()
tictoc::toc()
as.character(glue("Part 2 solution: {answer}"))
library(tidyverse)
x = unlist(str_split(readLines("input.txt"), pattern = ","))
df = tibble(x) |>
separate(x, into = c("l", "r"), sep = "-", remove = FALSE, convert = TRUE)
# max number of digits across all endpoints
max_digits = max(nchar(c(df$l, df$r)))
# if max_digits < 2 there are no invalid IDs
if (max_digits < 2) {
answer = 0
} else {
# generate all possible invalid numbers (pasted pattern repeated twice)
all_invalid =
seq(2, max_digits, by = 2) |>
map(function(total_len) {
half_len = total_len / 2
start = 10^(half_len - 1)
end = (10^half_len) - 1
patterns = seq(start, end)
as.numeric(paste0(patterns, patterns))
}) |>
unlist() |>
unique() |>
sort()
# filter which fall inside each input range and sum them
answer =
df |>
mutate(invalid = map2(l, r, function(a, b) all_invalid[all_invalid >= a & all_invalid <= b])) |>
pull(invalid) |>
unlist() |>
sum()
}
answer
# max number of digits across all endpoints
max_digits = max(nchar(c(df$l, df$r)))
# if max_digits < 2 there are no invalid IDs
if (max_digits < 2) {
answer = 0
} else {
# generate all possible invalid numbers (pasted pattern repeated twice)
all_invalid = seq(2, max_digits, by = 2) |>
map(function(total_len) {
half_len = total_len / 2
start = 10 ^ (half_len - 1)
end = (10 ^ half_len) - 1
patterns = seq(start, end)
as.numeric(paste0(patterns, patterns))
}) |>
unlist() |>
unique() |>
sort()
# filter which fall inside each input range and sum them
answer = df |>
mutate(invalid = map2(
l, r, function(a, b) all_invalid[all_invalid >= a & all_invalid <= b]
)) |>
pull(invalid) |>
unlist() |>
sum()
}
answer
tictoc::tic()
# max number of digits across all endpoints
max_digits = max(nchar(c(df$l, df$r)))
# if max_digits < 2 there are no invalid IDs
if (max_digits < 2) {
answer = 0
} else {
# generate all possible invalid numbers (pasted pattern repeated twice)
all_invalid = seq(2, max_digits, by = 2) |>
map(function(total_len) {
half_len = total_len / 2
start = 10 ^ (half_len - 1)
end = (10 ^ half_len) - 1
patterns = seq(start, end)
as.numeric(paste0(patterns, patterns))
}) |>
unlist() |>
unique() |>
sort()
# filter which fall inside each input range and sum them
answer = df |>
mutate(invalid = map2(
l, r, function(a, b) all_invalid[all_invalid >= a & all_invalid <= b]
)) |>
pull(invalid) |>
unlist() |>
sum()
}
tictoc::toc()
as.character(glue("Part 2 solution: {answer}")
tictoc::tic()
# max number of digits across all endpoints
max_digits = max(nchar(c(df$l, df$r)))
# if max_digits < 2 there are no invalid IDs
if (max_digits < 2) {
answer = 0
} else {
# generate all possible invalid numbers (pasted pattern repeated twice)
all_invalid = seq(2, max_digits, by = 2) |>
map(function(total_len) {
half_len = total_len / 2
start = 10 ^ (half_len - 1)
end = (10 ^ half_len) - 1
patterns = seq(start, end)
as.numeric(paste0(patterns, patterns))
}) |>
unlist() |>
unique() |>
sort()
# filter which fall inside each input range and sum them
answer = df |>
mutate(invalid = map2(
l, r, function(a, b) all_invalid[all_invalid >= a & all_invalid <= b]
)) |>
pull(invalid) |>
unlist() |>
sum()
}
tictoc::toc()
as.character(glue("Part 2 solution: {answer}"))
# generate all invalid IDs for part two
all_invalid =
seq(1, max_digits) |>
map(function(L) {
# find all k such that pattern length k repeats >= 2 times
ks = seq(1, L) |> keep(function(k) L %% k == 0 && (L / k) >= 2)
if (length(ks) == 0) {
return(NULL)
}
map(ks, function(k) {
repeat_count = L / k
start = 10^(k - 1)
end = (10^k) - 1
patterns = seq(start, end)
map_chr(patterns, function(p) {
paste0(rep(p, repeat_count), collapse = "")
})
}) |>
unlist()
}) |>
unlist() |>
as.numeric() |>
unique() |>
sort()
answer =
df |>
mutate(invalid = map2(l, r, function(a, b) all_invalid[all_invalid >= a & all_invalid <= b])) |>
pull(invalid) |>
unlist() |>
sum()
answer
# generate all invalid IDs for part two
all_invalid =
seq(1, max_digits) |>
map(function(L) {
# find all k such that pattern length k repeats >= 2 times
ks = seq(1, L) |> keep(function(k) L %% k == 0 && (L / k) >= 2)
if (length(ks) == 0) {
return(NULL)
}
map(ks, function(k) {
repeat_count = L / k
start = 10 ^ (k - 1)
end = (10 ^ k) - 1
patterns = seq(start, end)
map_chr(patterns, function(p) {
paste0(rep(p, repeat_count), collapse = "")
})
}) |>
unlist()
}) |>
unlist() |>
as.numeric() |>
unique() |>
sort()
answer =
df |>
mutate(invalid = map2(
l, r, function(a, b) all_invalid[all_invalid >= a & all_invalid <= b]
)) |>
pull(invalid) |>
unlist() |>
sum()
answer
tictoc::tic()
# generate all invalid IDs for part two
all_invalid =
seq(1, max_digits) |>
map(function(L) {
# find all k such that pattern length k repeats >= 2 times
ks = seq(1, L) |> keep(function(k) L %% k == 0 && (L / k) >= 2)
if (length(ks) == 0) {
return(NULL)
}
map(ks, function(k) {
repeat_count = L / k
start = 10 ^ (k - 1)
end = (10 ^ k) - 1
patterns = seq(start, end)
map_chr(patterns, function(p) {
paste0(rep(p, repeat_count), collapse = "")
})
}) |>
unlist()
}) |>
unlist() |>
as.numeric() |>
unique() |>
sort()
sol = df |>
mutate(invalid = map2(
l, r, function(a, b) all_invalid[all_invalid >= a & all_invalid <= b]
)) |>
pull(invalid) |>
unlist() |>
sum()
tictoc::toc()
as.character(glue("Part 2 solution: {sol}"))
