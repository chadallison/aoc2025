---
title: "day09"
output: html_document
---

```{r message = F, warning = F}
tictoc::tic()
library(tidyverse)
library(glue)

input = readLines("input.txt")

df = tibble(x = input) |>
  separate(x, into = c("l", "r"), sep = ",", convert = T, remove = T)

pairs = expand_grid(a = 1:nrow(df), b = 1:nrow(df)) |>
  filter(a < b) |>
  left_join(df |> mutate(a = row_number()) |> rename(xa = l, ya = r), by = "a") |>
  left_join(df |> mutate(b = row_number()) |> rename(xb = l, yb = r), by = "b") |>
  mutate(dx = abs(xa - xb) + 1,
         dy = abs(ya - yb) + 1,
         area = dx * dy)

sol = max(pairs$area)
as.character(glue("Part 1 solution: {sol}"))

v_x = df$l
v_y = df$r
N = length(v_x)
xs = sort(unique(v_x))
ys = sort(unique(v_y))
map_x = match(v_x, xs)
map_y = match(v_y, ys)
Nx = length(xs)
Ny = length(ys)
B = matrix(F, nrow = Nx, ncol = Ny)
C = matrix(0, nrow = Nx, ncol = Ny)

for (i in 1:N) {
  i_next = (i %% N) + 1
    ix1 = map_x[i]; iy1 = map_y[i]
  ix2 = map_x[i_next]; iy2 = map_y[i_next]
  
  if (ix1 == ix2) {
    B[ix1, min(iy1, iy2):max(iy1, iy2)] = T
  } else {
    B[min(ix1, ix2):max(ix1, ix2), iy1] = T
  }
  
  if (ix1 == ix2) {
    if (iy2 > iy1) {
      if (iy2 > iy1) C[ix1, iy1:(iy2 - 1)] = C[ix1, iy1:(iy2 - 1)] + 1
    } else {
      if (iy1 > iy2) C[ix1, iy2:(iy1 - 1)] = C[ix1, iy2:(iy1 - 1)] - 1
    }
  }
}

W = apply(C, 2, cumsum)
Is_Valid = (W != 0) | B
Grid = matrix(as.integer(Is_Valid), nrow = Nx, ncol = Ny)
P = t(apply(apply(Grid, 2, cumsum), 1, cumsum))

get_grid_sum_vectorized = function(idx_x1, idx_y1, idx_x2, idx_y2) {
  xa = pmin(idx_x1, idx_x2); xb = pmax(idx_x1, idx_x2)
  ya = pmin(idx_y1, idx_y2); yb = pmax(idx_y1, idx_y2)
  res = P[cbind(xb, yb)]
  left_mask = xa > 1
  if (any(left_mask)) res[left_mask] = res[left_mask] - P[cbind(xa[left_mask] - 1, yb[left_mask])]
  top_mask = ya > 1
  if (any(top_mask)) res[top_mask] = res[top_mask] - P[cbind(xb[top_mask], ya[top_mask] - 1)]
  corner_mask = xa > 1 & ya > 1
  if (any(corner_mask)) res[corner_mask] = res[corner_mask] + P[cbind(xa[corner_mask] - 1, ya[corner_mask] - 1)]
  return(res)
}

pairs_indices = expand_grid(a = 1:N, b = 1:N) |>
  filter(a < b) |>
  mutate(ix1 = map_x[a], iy1 = map_y[a],
         ix2 = map_x[b], iy2 = map_y[b])

final_results = pairs_indices |>
  mutate(grid_w = abs(ix1 - ix2) + 1,
         grid_h = abs(iy1 - iy2) + 1,
         total_grid_points = grid_w * grid_h,
         valid_points = get_grid_sum_vectorized(ix1, iy1, ix2, iy2)) |>
  filter(valid_points == total_grid_points) |>
  mutate(xa = xs[ix1], ya = ys[iy1],
         xb = xs[ix2], yb = ys[iy2],
         real_area = (abs(xa - xb) + 1) * (abs(ya - yb) + 1))

sol2 = max(final_results$real_area)
as.character(glue("Part 2 solution: {sol2}"))
tictoc::toc()
```

