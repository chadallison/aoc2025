coord_index = coord_index + 1
}
} else { # Horizontal segment
for (x in min(x1, x2):max(x1, x2)) {
boundary_coords[[coord_index]] = paste(x, y1, sep = ",")
coord_index = coord_index + 1
}
}
}
B_set = unique(unlist(boundary_coords))
# B. Interior Tiles (I) - iterate over bounding box and check interior points
I_set = c()
# Iterate over interior grid points only
for (x in (x_min + 1):(x_max - 1)) {
for (y in (y_min + 1):(y_max - 1)) {
coord_key = paste(x, y, sep = ",")
if (!(coord_key %in% B_set)) {
if (is_inside_polygon_p2_fast(x, y, v_x, v_y)) {
I_set = c(I_set, coord_key)
}
}
}
}
# --- FINAL OPTIMIZED O(N^3) SOLUTION (RELYING ON N, NOT GRID SIZE) ---
# This solution returns to the original logic: check all pairs, but ensures
# the geometric check is mathematically robust for large coordinates.
v_x = df$l
v_y = df$r
N = length(v_x)
# Function to check if a point (px, py) is inside or on the boundary of the polygon
# Complexity: O(N) per call. Total solution: O(N^3)
is_inside_polygon_p3 = function(px, py, vx, vy, n_vert) {
winding_number = 0
for (i in 1:n_vert) {
x1 = vx[i]; y1 = vy[i]
x2 = vx[(i %% n_vert) + 1]; y2 = vy[(i %% n_vert) + 1]
# 1. Boundary Check: This must be precise for large coordinates
# We check if the point (px, py) is on the orthogonal segment (x1, y1) to (x2, y2)
on_segment = FALSE
if (x1 == x2 && px == x1 && py >= min(y1, y2) && py <= max(y1, y2)) {
on_segment = TRUE
} else if (y1 == y2 && py == y1 && px >= min(x1, x2) && px <= max(x1, x2)) {
on_segment = TRUE
}
if (on_segment) {
return(TRUE)
}
# 2. Winding Number Check: Must handle large coordinate multiplication
if (y1 <= py) {
if (y2 > py) { # An upward crossing
# Cross product (x2 - x1) * (py - y1) - (y2 - y1) * (px - x1)
# Use a high-precision calculation or check the sign carefully
# Here we rely on R's floating-point precision for the comparison:
if ((x2 - x1) * (py - y1) > (y2 - y1) * (px - x1)) {
winding_number = winding_number + 1
}
}
} else {
if (y2 <= py) { # A downward crossing
if ((x2 - x1) * (py - y1) < (y2 - y1) * (px - x1)) {
winding_number = winding_number - 1
}
}
}
}
return(winding_number != 0)
}
# 3. Filter the existing `pairs` data frame
valid_pairs_part2_final = pairs |>
rowwise() |>
# Check if corner C = (xa, yb) is valid
mutate(is_c_valid = is_inside_polygon_p3(xa, yb, v_x, v_y, N)) |>
# Check if corner D = (xb, ya) is valid
mutate(is_d_valid = is_inside_polygon_p3(xb, ya, v_x, v_y, N)) |>
# Filter for rectangles where both off-diagonal corners are in the Red/Green region
filter(is_c_valid & is_d_valid) |>
ungroup()
# 4. Find the maximum area
sol2_final = max(valid_pairs_part2_final$area)
as.character(glue("Part 2 solution: {sol2_final}"))
# --- CORRECTED FINAL SOLUTION (O(N^3)) ---
v_x = df$l
v_y = df$r
N = length(v_x)
# Corrected Function to check if a tile at (px, py) is inside or on the boundary of the polygon
# The tile at (px, py) is represented by the point (px + 0.5, py + 0.5) for Winding Number calculation.
is_valid_tile = function(px, py, vx, vy, n_vert) {
# We check the center of the tile: (px + 0.5, py + 0.5)
# This avoids ambiguity with points lying exactly on vertices or edges.
check_x = px + 0.5
check_y = py + 0.5
winding_number = 0
for (i in 1:n_vert) {
x1 = vx[i]; y1 = vy[i]
x2 = vx[(i %% n_vert) + 1]; y2 = vy[(i %% n_vert) + 1]
# --- 1. Boundary Check (Tiles) ---
# The segment from (x1, y1) to (x2, y2) includes all tiles along the path.
# Check if the tile (px, py) is one of the red/green tiles on the boundary.
on_boundary = FALSE
if (x1 == x2) { # Vertical segment tiles
if (px == x1 && py >= min(y1, y2) && py <= max(y1, y2)) {
on_boundary = TRUE
}
} else if (y1 == y2) { # Horizontal segment tiles
if (py == y1 && px >= min(x1, x2) && px <= max(x1, x2)) {
on_boundary = TRUE
}
}
if (on_boundary) {
return(TRUE)
}
# --- 2. Winding Number Check (Interior) ---
# We use the tile center (check_x, check_y) for the ray casting algorithm.
if (y1 <= check_y) {
if (y2 > check_y) { # Upward crossing
# Cross product (x2 - x1) * (check_y - y1) - (y2 - y1) * (check_x - x1)
if ((x2 - x1) * (check_y - y1) > (y2 - y1) * (check_x - x1)) {
winding_number = winding_number + 1
}
}
} else {
if (y2 <= check_y) { # Downward crossing
if ((x2 - x1) * (check_y - y1) < (y2 - y1) * (check_x - x1)) {
winding_number = winding_number - 1
}
}
}
}
# If winding_number is non-zero, the tile center is inside the polygon.
return(winding_number != 0)
}
# 3. Filter the existing `pairs` data frame
valid_pairs_part2_final = pairs |>
rowwise() |>
# Check if corner C = (xa, yb) is valid
mutate(is_c_valid = is_valid_tile(xa, yb, v_x, v_y, N)) |>
# Check if corner D = (xb, ya) is valid
mutate(is_d_valid = is_valid_tile(xb, ya, v_x, v_y, N)) |>
# Filter for rectangles where both off-diagonal corners are in the Red/Green region
filter(is_c_valid & is_d_valid) |>
ungroup()
# 4. Find the maximum area
sol2_final = max(valid_pairs_part2_final$area)
as.character(glue("Part 2 solution: {sol2_final}"))
# --- FINAL ATTEMPT: CORRECTED PIP LOGIC ---
# df, pairs, v_x, v_y, N are assumed to be defined from previous steps.
# Function to check if a tile at (px, py) is inside or on the boundary.
# Checks the tile center (px + 0.5, py + 0.5) against the polygon defined by vertices (vx, vy).
is_valid_tile_final = function(px, py, vx, vy, n_vert) {
# Center of the tile
check_x = px + 0.5
check_y = py + 0.5
winding_number = 0
for (i in 1:n_vert) {
x1 = vx[i]; y1 = vy[i]
x2 = vx[(i %% n_vert) + 1]; y2 = vy[(i %% n_vert) + 1]
# 1. Boundary Check (Discrete Tiles)
# Check if the tile (px, py) is on the line segment including endpoints
on_boundary = FALSE
if (x1 == x2) { # Vertical segment
if (px == x1 && py >= min(y1, y2) && py <= max(y1, y2)) {
on_boundary = TRUE
}
} else if (y1 == y2) { # Horizontal segment
if (py == y1 && px >= min(x1, x2) && px <= max(x1, x2)) {
on_boundary = TRUE
}
}
if (on_boundary) {
return(TRUE)
}
# 2. Winding Number Check (Tile Center)
# This must use the continuous coordinates (x, y) for the vertices
# and the floating point center of the tile (check_x, check_y)
# Handle crossings and use the cross-product to determine if the crossing is to the right
if (y1 <= check_y) {
if (y2 > check_y) { # Upward crossing
if ((x2 - x1) * (check_y - y1) > (y2 - y1) * (check_x - x1)) {
winding_number = winding_number + 1
}
}
} else {
if (y2 <= check_y) { # Downward crossing
if ((x2 - x1) * (check_y - y1) < (y2 - y1) * (check_x - x1)) {
winding_number = winding_number - 1
}
}
}
}
# If winding_number is non-zero, the tile center is inside the polygon's area.
return(winding_number != 0)
}
# 3. Filter the existing `pairs` data frame
valid_pairs_part2_final_correct = pairs |>
rowwise() |>
# Check corner C = (xa, yb)
mutate(is_c_valid = is_valid_tile_final(xa, yb, v_x, v_y, N)) |>
# Check corner D = (xb, ya)
mutate(is_d_valid = is_valid_tile_final(xb, ya, v_x, v_y, N)) |>
# Crucial second filter: Check a point **inside** the rectangle boundary.
# This helps catch the "notch" case where corners are valid but the interior isn't.
# We check the tile one step in from the off-diagonal corner, (xa+sign(xb-xa), yb)
mutate(
mid_x = floor((xa + xb) / 2),
mid_y = floor((ya + yb) / 2),
is_center_valid = is_valid_tile_final(mid_x, mid_y, v_x, v_y, N)
) |>
# The entire rectangle is valid only if the two off-diagonal corners are valid
# AND a representative point in the center is also valid.
filter(is_c_valid & is_d_valid & is_center_valid) |>
ungroup()
# 4. Find the maximum area
sol2_final_correct = max(valid_pairs_part2_final_correct$area)
as.character(glue("Part 2 solution: {sol2_final_correct}"))
library(tidyverse)
library(glue)
# --- 1. Load and Prepare Data ---
input = readLines("input.txt")
df = tibble(x = input) |>
separate(x, into = c("l", "r"), sep = ",", convert = T, remove = T)
# Extract vertices
v_x = df$l
v_y = df$r
N = length(v_x)
# --- 2. Coordinate Compression ---
# We only care about x and y coordinates that appear in the input.
# This shrinks the effective grid size from billions to ~N*N.
xs = sort(unique(v_x))
ys = sort(unique(v_y))
# Create mapping functions (coord -> index)
map_x = match(v_x, xs)
map_y = match(v_y, ys)
Nx = length(xs)
Ny = length(ys)
# --- 3. Build the Grid Matrices ---
# B: Boundary Matrix (TRUE if tile is on the polygon boundary)
# C: Crossing Matrix (Used to calculate interior via Winding Number)
B = matrix(FALSE, nrow = Nx, ncol = Ny)
C = matrix(0, nrow = Nx, ncol = Ny)
for (i in 1:N) {
i_next = (i %% N) + 1
# Get indices for start and end of segment
ix1 = map_x[i]; iy1 = map_y[i]
ix2 = map_x[i_next]; iy2 = map_y[i_next]
# 1. Mark Boundary (B)
if (ix1 == ix2) { # Vertical
B[ix1, min(iy1, iy2):max(iy1, iy2)] = TRUE
} else { # Horizontal
B[min(ix1, ix2):max(ix1, ix2), iy1] = TRUE
}
# 2. Mark Crossings for Winding Number (C)
# Only vertical edges change the winding number as we sweep across X.
# We use the half-open interval [y_start, y_end) to ensure corners don't double-count.
if (ix1 == ix2) {
if (iy2 > iy1) { # Upward edge
# Look at the cells strictly between the y-indices
if (iy2 > iy1) C[ix1, iy1:(iy2 - 1)] = C[ix1, iy1:(iy2 - 1)] + 1
} else { # Downward edge
if (iy1 > iy2) C[ix1, iy2:(iy1 - 1)] = C[ix1, iy2:(iy1 - 1)] - 1
}
}
}
# --- 4. Fill Interior (Scanline) ---
# Calculate Winding Number by summing crossings cumulatively along the X-axis (rows)
# apply(C, 2, cumsum) does col-wise, so we transpose logic or just map carefully.
# We want: W[x, y] = sum(C[1:x, y])
W = apply(C, 2, cumsum)
# A tile is valid if it is Interior (W != 0) OR on the Boundary (B)
Is_Valid = (W != 0) | B
# --- 5. Create 2D Prefix Sum (Integral Image) ---
# This allows us to count valid tiles in ANY rectangle in O(1) time.
# Convert boolean to integer (1 for valid, 0 for invalid)
Grid = as.integer(Is_Valid)
# Cumulative sum along rows, then columns
P = t(apply(apply(Grid, 2, cumsum), 1, cumsum))
library(tidyverse)
library(glue)
# --- 1. Load and Prepare Data ---
input = readLines("input.txt")
df = tibble(x = input) |>
separate(x, into = c("l", "r"), sep = ",", convert = T, remove = T)
# Extract vertices
v_x = df$l
v_y = df$r
N = length(v_x)
# --- 2. Coordinate Compression ---
# Shrink the infinite grid to just the unique X/Y coordinates present in the data.
# This makes the problem solvable even if coordinates are in the billions.
xs = sort(unique(v_x))
ys = sort(unique(v_y))
# Create mapping: Coordinate -> Grid Index
map_x = match(v_x, xs)
map_y = match(v_y, ys)
Nx = length(xs)
Ny = length(ys)
# --- 3. Build the Grid Matrices ---
# B: Boundary Matrix (TRUE if the intersection is on the polygon boundary)
# C: Crossing Matrix (Used to calculate interior via Winding Number)
B = matrix(FALSE, nrow = Nx, ncol = Ny)
C = matrix(0, nrow = Nx, ncol = Ny)
for (i in 1:N) {
i_next = (i %% N) + 1
# Get grid indices for start and end of segment
ix1 = map_x[i]; iy1 = map_y[i]
ix2 = map_x[i_next]; iy2 = map_y[i_next]
# 1. Mark Boundary (B)
if (ix1 == ix2) { # Vertical segment
B[ix1, min(iy1, iy2):max(iy1, iy2)] = TRUE
} else { # Horizontal segment
B[min(ix1, ix2):max(ix1, ix2), iy1] = TRUE
}
# 2. Mark Crossings for Winding Number (C)
# Only vertical edges affect the horizontal winding number scan
if (ix1 == ix2) {
if (iy2 > iy1) { # Upward edge
# Mark +1 for the interval [y1, y2)
if (iy2 > iy1) C[ix1, iy1:(iy2 - 1)] = C[ix1, iy1:(iy2 - 1)] + 1
} else { # Downward edge
# Mark -1 for the interval [y2, y1)
if (iy1 > iy2) C[ix1, iy2:(iy1 - 1)] = C[ix1, iy2:(iy1 - 1)] - 1
}
}
}
# --- 4. Fill Interior (Scanline) ---
# Calculate Winding Number by summing crossings cumulatively along the X-axis (rows)
# apply(..., 2, cumsum) works on columns, so we transpose logic or just map carefully.
# We want W[x, y] to be sum of C[1:x, y].
# apply(C, 2, cumsum) returns a matrix where column j is cumsum(C[,j]), which is exactly what we want.
W = apply(C, 2, cumsum)
# A tile is valid if it is Interior (W != 0) OR on the Boundary (B)
Is_Valid = (W != 0) | B
# --- 5. Create 2D Prefix Sum (Integral Image) ---
# This allows us to count valid tiles in ANY rectangle in O(1) time.
# FIX: Force preservation of dimensions when converting to integer
Grid = matrix(as.integer(Is_Valid), nrow = Nx, ncol = Ny)
# Cumulative sum along rows (margin 2), then columns (margin 1)
# Note: apply(mat, 1, fun) returns transposed result, so we transpose t() back at the end.
P = t(apply(apply(Grid, 2, cumsum), 1, cumsum))
# Now P[x, y] contains sum of Grid[1:x, 1:y]
# Helper function to get sum of rect defined by indices (x1, y1) to (x2, y2)
get_grid_sum_vectorized = function(idx_x1, idx_y1, idx_x2, idx_y2) {
xa = pmin(idx_x1, idx_x2); xb = pmax(idx_x1, idx_x2)
ya = pmin(idx_y1, idx_y2); yb = pmax(idx_y1, idx_y2)
# Get values from P using matrix indexing
# We need to handle 0 carefully (if index-1 < 1)
# Total up to bottom-right
res = P[cbind(xb, yb)]
# Subtract left strip (only if xa > 1)
left_mask = xa > 1
if(any(left_mask)) res[left_mask] = res[left_mask] - P[cbind(xa[left_mask]-1, yb[left_mask])]
# Subtract top strip (only if ya > 1)
top_mask = ya > 1
if(any(top_mask)) res[top_mask] = res[top_mask] - P[cbind(xb[top_mask], ya[top_mask]-1)]
# Add back top-left corner (only if xa > 1 and ya > 1)
corner_mask = xa > 1 & ya > 1
if(any(corner_mask)) res[corner_mask] = res[corner_mask] + P[cbind(xa[corner_mask]-1, ya[corner_mask]-1)]
return(res)
}
# --- 6. Solve Part 2 ---
# Map all red tile pairs to their grid indices
# We use the indices to check validity, but original coords for Area
pairs_indices = expand_grid(a = 1:N, b = 1:N) |>
filter(a < b) |>
mutate(
ix1 = map_x[a], iy1 = map_y[a],
ix2 = map_x[b], iy2 = map_y[b]
)
# Calculate results
final_results = pairs_indices |>
mutate(
# How many grid intersection points are in this rectangle?
grid_w = abs(ix1 - ix2) + 1,
grid_h = abs(iy1 - iy2) + 1,
total_grid_points = grid_w * grid_h,
# How many VALID grid points are in this rectangle? (O(1) lookup)
valid_points = get_grid_sum_vectorized(ix1, iy1, ix2, iy2)
) |>
# The rectangle is valid if and only if 100% of the grid points inside it are valid
filter(valid_points == total_grid_points) |>
# Calculate actual area using original coordinates
mutate(
xa = xs[ix1], ya = ys[iy1],
xb = xs[ix2], yb = ys[iy2],
real_area = (abs(xa - xb) + 1) * (abs(ya - yb) + 1)
)
sol2 = max(final_results$real_area)
as.character(glue("Part 2 solution: {sol2}"))
setwd("~/r_projects/aoc25/day09")
tictoc::tic()
library(tidyverse)
library(glue)
input = readLines("input.txt")
df = tibble(x = input) |>
separate(x, into = c("l", "r"), sep = ",", convert = T, remove = T)
pairs = expand_grid(a = 1:nrow(df), b = 1:nrow(df)) |>
filter(a < b) |>
left_join(df |> mutate(a = row_number()) |> rename(xa = l, ya = r), by = "a") |>
left_join(df |> mutate(b = row_number()) |> rename(xb = l, yb = r), by = "b") |>
mutate(dx = abs(xa - xb) + 1,
dy = abs(ya - yb) + 1,
area = dx * dy)
sol = max(pairs$area)
as.character(glue("Part 1 solution: {sol}"))
# Extract vertices
v_x = df$l
v_y = df$r
N = length(v_x)
# --- 2. Coordinate Compression ---
# Shrink the infinite grid to just the unique X/Y coordinates present in the data.
# This makes the problem solvable even if coordinates are in the billions.
xs = sort(unique(v_x))
ys = sort(unique(v_y))
# Create mapping: Coordinate -> Grid Index
map_x = match(v_x, xs)
map_y = match(v_y, ys)
Nx = length(xs)
Ny = length(ys)
# --- 3. Build the Grid Matrices ---
# B: Boundary Matrix (TRUE if the intersection is on the polygon boundary)
# C: Crossing Matrix (Used to calculate interior via Winding Number)
B = matrix(FALSE, nrow = Nx, ncol = Ny)
C = matrix(0, nrow = Nx, ncol = Ny)
for (i in 1:N) {
i_next = (i %% N) + 1
# Get grid indices for start and end of segment
ix1 = map_x[i]; iy1 = map_y[i]
ix2 = map_x[i_next]; iy2 = map_y[i_next]
# 1. Mark Boundary (B)
if (ix1 == ix2) { # Vertical segment
B[ix1, min(iy1, iy2):max(iy1, iy2)] = TRUE
} else { # Horizontal segment
B[min(ix1, ix2):max(ix1, ix2), iy1] = TRUE
}
# 2. Mark Crossings for Winding Number (C)
# Only vertical edges affect the horizontal winding number scan
if (ix1 == ix2) {
if (iy2 > iy1) { # Upward edge
# Mark +1 for the interval [y1, y2)
if (iy2 > iy1) C[ix1, iy1:(iy2 - 1)] = C[ix1, iy1:(iy2 - 1)] + 1
} else { # Downward edge
# Mark -1 for the interval [y2, y1)
if (iy1 > iy2) C[ix1, iy2:(iy1 - 1)] = C[ix1, iy2:(iy1 - 1)] - 1
}
}
}
# --- 4. Fill Interior (Scanline) ---
# Calculate Winding Number by summing crossings cumulatively along the X-axis (rows)
# apply(..., 2, cumsum) works on columns, so we transpose logic or just map carefully.
# We want W[x, y] to be sum of C[1:x, y].
# apply(C, 2, cumsum) returns a matrix where column j is cumsum(C[,j]), which is exactly what we want.
W = apply(C, 2, cumsum)
# A tile is valid if it is Interior (W != 0) OR on the Boundary (B)
Is_Valid = (W != 0) | B
# --- 5. Create 2D Prefix Sum (Integral Image) ---
# This allows us to count valid tiles in ANY rectangle in O(1) time.
# FIX: Force preservation of dimensions when converting to integer
Grid = matrix(as.integer(Is_Valid), nrow = Nx, ncol = Ny)
# Cumulative sum along rows (margin 2), then columns (margin 1)
# Note: apply(mat, 1, fun) returns transposed result, so we transpose t() back at the end.
P = t(apply(apply(Grid, 2, cumsum), 1, cumsum))
# Now P[x, y] contains sum of Grid[1:x, 1:y]
# Helper function to get sum of rect defined by indices (x1, y1) to (x2, y2)
get_grid_sum_vectorized = function(idx_x1, idx_y1, idx_x2, idx_y2) {
xa = pmin(idx_x1, idx_x2); xb = pmax(idx_x1, idx_x2)
ya = pmin(idx_y1, idx_y2); yb = pmax(idx_y1, idx_y2)
# Get values from P using matrix indexing
# We need to handle 0 carefully (if index-1 < 1)
# Total up to bottom-right
res = P[cbind(xb, yb)]
# Subtract left strip (only if xa > 1)
left_mask = xa > 1
if(any(left_mask)) res[left_mask] = res[left_mask] - P[cbind(xa[left_mask]-1, yb[left_mask])]
# Subtract top strip (only if ya > 1)
top_mask = ya > 1
if(any(top_mask)) res[top_mask] = res[top_mask] - P[cbind(xb[top_mask], ya[top_mask]-1)]
# Add back top-left corner (only if xa > 1 and ya > 1)
corner_mask = xa > 1 & ya > 1
if(any(corner_mask)) res[corner_mask] = res[corner_mask] + P[cbind(xa[corner_mask]-1, ya[corner_mask]-1)]
return(res)
}
# --- 6. Solve Part 2 ---
# Map all red tile pairs to their grid indices
# We use the indices to check validity, but original coords for Area
pairs_indices = expand_grid(a = 1:N, b = 1:N) |>
filter(a < b) |>
mutate(
ix1 = map_x[a], iy1 = map_y[a],
ix2 = map_x[b], iy2 = map_y[b]
)
# Calculate results
final_results = pairs_indices |>
mutate(
# How many grid intersection points are in this rectangle?
grid_w = abs(ix1 - ix2) + 1,
grid_h = abs(iy1 - iy2) + 1,
total_grid_points = grid_w * grid_h,
# How many VALID grid points are in this rectangle? (O(1) lookup)
valid_points = get_grid_sum_vectorized(ix1, iy1, ix2, iy2)
) |>
# The rectangle is valid if and only if 100% of the grid points inside it are valid
filter(valid_points == total_grid_points) |>
# Calculate actual area using original coordinates
mutate(
xa = xs[ix1], ya = ys[iy1],
xb = xs[ix2], yb = ys[iy2],
real_area = (abs(xa - xb) + 1) * (abs(ya - yb) + 1)
)
sol2 = max(final_results$real_area)
as.character(glue("Part 2 solution: {sol2}"))
tictoc::toc()
tictoc::toc()
tictoc::toc()
