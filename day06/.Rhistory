library(glue)
input = readLines("input.txt")
grid = str_split(input, pattern = "", simplify = T)
nrow = nrow(grid)
ncol = ncol(grid)
start_col = which(grid[1, ] == "S")
# pre-index splitters: for each column, store rows of "^"
splitters = vector("list", ncol)
for (c in 1:ncol) {
splitters[[c]] = which(grid[, c] == "^")
}
# queue stored as integer vectors
beam_r = integer(1)
beam_c = integer(1)
beam_r[1] = 1L
beam_c[1] = start_col
head_idx = 1L
tail_idx = 1L
splits = 0L
# visited cells to avoid reprocessing; mark both arrival positions and splitter cells
visited = matrix(F, nrow = nrow, ncol = ncol)
while (head_idx <= tail_idx) {
r = beam_r[head_idx]
c = beam_c[head_idx]
head_idx = head_idx + 1L
if (r > nrow) next
if (c < 1L || c > ncol) next
# if we've already processed a beam arriving at this cell, skip
if (visited[r, c]) next
visited[r, c] = T
# find next splitter in this column strictly below r
sp = splitters[[c]]
if (length(sp) == 0L) next
idx = which(sp > r)
if (length(idx) == 0L) next
nr = sp[idx[1]] # next splitter row in this column
# if that splitter was already handled, skip counting/spawning
if (visited[nr, c]) next
# mark the splitter as handled and count the split
visited[nr, c] = T
splits = splits + 1L
# spawn left beam from row nr + 1, col c - 1
lr = nr + 1L
lc = c - 1L
if (lr <= nrow && lc >= 1L && lc <= ncol) {
tail_idx = tail_idx + 1L
beam_r[tail_idx] = lr
beam_c[tail_idx] = lc
}
# spawn right beam from row nr + 1, col c + 1
rr = nr + 1L
rc = c + 1L
if (rr <= nrow && rc >= 1L && rc <= ncol) {
tail_idx = tail_idx + 1L
beam_r[tail_idx] = rr
beam_c[tail_idx] = rc
}
}
sol = splits
as.character(glue("Part 1 solution: {sol}"))
# as.character(glue("Part 2 solution: {sol}"))
tictoc::toc()
tictoc::tic()
library(tidyverse)
library(glue)
input = readLines("input.txt")
grid = str_split(input, pattern = "", simplify = T)
nrow = nrow(grid)
ncol = ncol(grid)
start_col = which(grid[1, ] == "S")
# pre-index splitters: for each column, store rows of "^"
splitters = vector("list", ncol)
for (c in 1:ncol) {
splitters[[c]] = which(grid[, c] == "^")
}
# queue stored as integer vectors
beam_r = integer(1)
beam_c = integer(1)
beam_r[1] = 1L
beam_c[1] = start_col
head_idx = 1L
tail_idx = 1L
splits = 0L
# visited cells to avoid reprocessing; mark both arrival positions and splitter cells
visited = matrix(F, nrow = nrow, ncol = ncol)
while (head_idx <= tail_idx) {
r = beam_r[head_idx]
c = beam_c[head_idx]
head_idx = head_idx + 1L
if (r > nrow) next
if (c < 1L || c > ncol) next
# if we've already processed a beam arriving at this cell, skip
if (visited[r, c]) next
visited[r, c] = T
# find next splitter in this column strictly below r
sp = splitters[[c]]
if (length(sp) == 0L) next
idx = which(sp > r)
if (length(idx) == 0L) next
nr = sp[idx[1]] # next splitter row in this column
# if that splitter was already handled, skip counting/spawning
if (visited[nr, c]) next
# mark the splitter as handled and count the split
visited[nr, c] = T
splits = splits + 1L
# spawn left beam from row nr + 1, col c - 1
lr = nr + 1L
lc = c - 1L
if (lr <= nrow && lc >= 1L && lc <= ncol) {
tail_idx = tail_idx + 1L
beam_r[tail_idx] = lr
beam_c[tail_idx] = lc
}
# spawn right beam from row nr + 1, col c + 1
rr = nr + 1L
rc = c + 1L
if (rr <= nrow && rc >= 1L && rc <= ncol) {
tail_idx = tail_idx + 1L
beam_r[tail_idx] = rr
beam_c[tail_idx] = rc
}
}
sol = splits
as.character(glue("Part 1 solution: {sol}"))
grid = str_split(input, pattern = "", simplify = TRUE)
nrow = nrow(grid)
ncol = ncol(grid)
start_col = which(grid[1, ] == "S")
# numeric counts per column for the current row (number of timelines arriving)
cur = numeric(ncol)
cur[start_col] = 1
exited = 0
for (r in 1:nrow) {
nxt = numeric(ncol)
# treat "S" like empty space
rowcells = grid[r, ]
rowcells[rowcells == "S"] = "."
# straight-through cells (.) contribute to same column in next row
straight_idx = which(rowcells == ".")
if (length(straight_idx) > 0L) {
nxt[straight_idx] = nxt[straight_idx] + cur[straight_idx]
}
# splitter cells (^) split into left and right at next row
split_idx = which(rowcells == "^")
if (length(split_idx) > 0L) {
# left contributions: col - 1
left_cols = split_idx - 1L
valid_left = which(left_cols >= 1L)
if (length(valid_left) > 0L) {
cols = left_cols[valid_left]
vals = cur[split_idx[valid_left]]
nxt[cols] = nxt[cols] + vals
}
# right contributions: col + 1
right_cols = split_idx + 1L
valid_right = which(right_cols <= ncol)
if (length(valid_right) > 0L) {
cols = right_cols[valid_right]
vals = cur[split_idx[valid_right]]
nxt[cols] = nxt[cols] + vals
}
# any left or right that would go out of bounds exits the manifold
if (any(left_cols < 1L)) {
exited = exited + sum(cur[ split_idx[ left_cols < 1L ] ])
}
if (any(right_cols > ncol)) {
exited = exited + sum(cur[ split_idx[ right_cols > ncol ] ])
}
}
# any straight-through contributions from the last row (r == nrow) actually exit
if (r == nrow) {
exited = exited + sum(nxt)
nxt[] = 0
}
cur = nxt
}
sol = exited
as.character(glue("Part 2 solution: {sol}"))
tictoc::toc()
tictoc::tic()
library(tidyverse)
library(glue)
input = readLines("input.txt")
grid = str_split(input, pattern = "", simplify = T)
nrow = nrow(grid)
ncol = ncol(grid)
start_col = which(grid[1, ] == "S")
# pre-index splitters: for each column, store rows of "^"
splitters = vector("list", ncol)
for (c in 1:ncol) {
splitters[[c]] = which(grid[, c] == "^")
}
# queue stored as integer vectors
beam_r = integer(1)
beam_c = integer(1)
beam_r[1] = 1L
beam_c[1] = start_col
head_idx = 1L
tail_idx = 1L
splits = 0L
# visited cells to avoid reprocessing; mark both arrival positions and splitter cells
visited = matrix(F, nrow = nrow, ncol = ncol)
while (head_idx <= tail_idx) {
r = beam_r[head_idx]
c = beam_c[head_idx]
head_idx = head_idx + 1L
if (r > nrow) next
if (c < 1L || c > ncol) next
# if we've already processed a beam arriving at this cell, skip
if (visited[r, c]) next
visited[r, c] = T
# find next splitter in this column strictly below r
sp = splitters[[c]]
if (length(sp) == 0L) next
idx = which(sp > r)
if (length(idx) == 0L) next
nr = sp[idx[1]] # next splitter row in this column
# if that splitter was already handled, skip counting/spawning
if (visited[nr, c]) next
# mark the splitter as handled and count the split
visited[nr, c] = T
splits = splits + 1L
# spawn left beam from row nr + 1, col c - 1
lr = nr + 1L
lc = c - 1L
if (lr <= nrow && lc >= 1L && lc <= ncol) {
tail_idx = tail_idx + 1L
beam_r[tail_idx] = lr
beam_c[tail_idx] = lc
}
# spawn right beam from row nr + 1, col c + 1
rr = nr + 1L
rc = c + 1L
if (rr <= nrow && rc >= 1L && rc <= ncol) {
tail_idx = tail_idx + 1L
beam_r[tail_idx] = rr
beam_c[tail_idx] = rc
}
}
sol = splits
as.character(glue("Part 1 solution: {sol}"))
grid = str_split(input, pattern = "", simplify = T)
nrow = nrow(grid)
ncol = ncol(grid)
start_col = which(grid[1, ] == "S")
# numeric counts per column for the current row (number of timelines arriving)
cur = numeric(ncol)
cur[start_col] = 1
exited = 0
for (r in 1:nrow) {
nxt = numeric(ncol)
# treat "S" like empty space
rowcells = grid[r, ]
rowcells[rowcells == "S"] = "."
# straight-through cells (.) contribute to same column in next row
straight_idx = which(rowcells == ".")
if (length(straight_idx) > 0L) {
nxt[straight_idx] = nxt[straight_idx] + cur[straight_idx]
}
# splitter cells (^) split into left and right at next row
split_idx = which(rowcells == "^")
if (length(split_idx) > 0L) {
# left contributions: col - 1
left_cols = split_idx - 1L
valid_left = which(left_cols >= 1L)
if (length(valid_left) > 0L) {
cols = left_cols[valid_left]
vals = cur[split_idx[valid_left]]
nxt[cols] = nxt[cols] + vals
}
# right contributions: col + 1
right_cols = split_idx + 1L
valid_right = which(right_cols <= ncol)
if (length(valid_right) > 0L) {
cols = right_cols[valid_right]
vals = cur[split_idx[valid_right]]
nxt[cols] = nxt[cols] + vals
}
# any left or right that would go out of bounds exits the manifold
if (any(left_cols < 1L)) {
exited = exited + sum(cur[ split_idx[left_cols < 1L] ])
}
if (any(right_cols > ncol)) {
exited = exited + sum(cur[ split_idx[right_cols > ncol]])
}
}
# any straight-through contributions from the last row (r == nrow) actually exit
if (r == nrow) {
exited = exited + sum(nxt)
nxt[] = 0
}
cur = nxt
}
sol = exited
as.character(glue("Part 2 solution: {sol}"))
tictoc::toc()
knitr::knit_hooks$set(source = function(x, options) {
hook.r = function(x, options) {
fence = "```"
language = tolower(options$engine)
if (language == "node") language = "javascript"
if (!options$highlight) language = "text"
if (!is.null(options$fold_code)) {
paste0("\n\n", "<details><summary>View Code</summary>\n", fence, language,
"\n", x, fence, "\n\n", "</details>\n")
} else paste0('\n\n', fence, language, '\n', x, fence,  '\n\n')
}
x = knitr:::hilight_source(x, "markdown", options)
hook.r(paste(c(x, ""), collapse = "\n"), options)
})
library(tidyverse)
library(tvthemes)
library(janitor)
library(glue)
library(cbbdata)
library(rvest)
library(readxl)
# library(stringdist) # fuzzy matching
theme_custom = theme_avatar() +
theme(plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5, size = 9, vjust = 2.5, face = "italic"),
plot.caption = element_text(face = "italic"),
panel.grid.major = element_line(linewidth = 0.5, colour = "#DFDAD1"),
panel.grid.minor = element_line(linewidth = 0.5, colour = "#DFDAD1"))
theme_set(theme_custom)
my_user = Sys.getenv("CBD_USER")
my_pw = Sys.getenv("CBD_PW")
cbd_login(username = my_user, password = my_pw)
get_kenpom_data = function() {
url = "https://kenpom.com/"
tbl = read_html(url) |>
html_nodes("table")
df = tbl[[1]] |>
html_table(fill = T)
kenpom_colnames = c(
"rank", "team", "conf", "record",
"net_rtg", "off_rtg", "off_rtg_rank", "def_rtg", "def_rtg_rank",
"adj_t", "adj_t_rank", "luck", "luck_rank",
"sos_net_rtg", "sos_net_rtg_rank",
"sos_off_rtg", "sos_off_rtg_rank",
"sos_def_rtg", "sos_def_rtg_rank",
"nc_sos_net_rtg", "nc_sos_net_rtg_rank"
)
df = df[-1, ] |>
setNames(kenpom_colnames) |>
filter(rank != "" & rank != "Rk") |>
separate(record, into = c("wins", "losses"), sep = "-", remove = F, convert = T) |>
mutate(gp = wins + losses, .before = "record") |>
mutate(win_pct = round(wins / gp, 3), .after = "losses") |>
mutate(rank = as.integer(rank),
net_rtg = as.double(net_rtg),
off_rtg = as.double(off_rtg),
off_rtg_rank = as.integer(off_rtg_rank),
def_rtg = as.double(def_rtg),
def_rtg_rank = as.integer(def_rtg_rank),
adj_t = as.double(adj_t),
adj_t_rank = as.integer(adj_t_rank),
luck = as.double(luck),
luck_rank = as.integer(luck_rank),
sos_net_rtg = as.double(sos_net_rtg),
sos_net_rtg_rank = as.integer(sos_net_rtg_rank),
sos_off_rtg = as.double(sos_off_rtg),
sos_off_rtg_rank = as.integer(sos_off_rtg_rank),
sos_def_rtg = as.double(sos_def_rtg),
sos_def_rtg_rank = as.integer(sos_def_rtg_rank),
nc_sos_net_rtg = as.double(nc_sos_net_rtg),
nc_sos_net_rtg_rank = as.integer(nc_sos_net_rtg_rank))
return(df)
}
kp = get_kenpom_data()
kp |>
filter(conf == "ACC") |>
ggplot(aes(off_rtg, def_rtg)) +
geom_point(aes(size = net_rtg)) +
ggrepel::geom_text_repel(aes(label = team), size = 3, max.overlaps = 30)
kp |>
filter(conf == "ACC") |>
ggplot(aes(off_rtg, def_rtg)) +
geom_point() +
ggrepel::geom_text_repel(aes(label = team), size = 3, max.overlaps = 30)
kp |>
filter(conf == "ACC") |>
ggplot(aes(off_rtg, def_rtg)) +
geom_point(shape = "square", size = 4) +
ggrepel::geom_text_repel(aes(label = team), size = 3, max.overlaps = 30)
cbbdata::cbd_teams()
cbbdata::cbd_teams() |>
distinct(kp_team, color)
cbd_teams() |>
distinct(kp_team, color)
teams_colors = cbd_teams() |>
distinct(kp_team, color)
kp |>
filter(conf == "ACC") |>
ggplot(aes(off_rtg, def_rtg)) +
geom_point(shape = "square", size = 4) +
ggrepel::geom_text_repel(aes(label = team), size = 3, max.overlaps = 30)
kp |>
filter(conf == "ACC") |>
inner_join(teams_colors, by = c("team" = "kp_team")) |>
ggplot(aes(off_rtg, def_rtg)) +
geom_point(shape = "square", size = 4) +
ggrepel::geom_text_repel(aes(label = team), size = 3, max.overlaps = 30)
kp |>
filter(conf == "ACC") |>
inner_join(teams_colors, by = c("team" = "kp_team")) |>
ggplot(aes(off_rtg, def_rtg)) +
geom_point(aes(col = color), shape = "square", size = 4) +
ggrepel::geom_text_repel(aes(label = team), size = 3, max.overlaps = 30)
kp |>
filter(conf == "ACC") |>
inner_join(teams_colors, by = c("team" = "kp_team")) |>
ggplot(aes(off_rtg, def_rtg)) +
geom_point(aes(col = color), shape = "square", size = 4) +
ggrepel::geom_text_repel(aes(label = team), size = 3, max.overlaps = 30) +
scale_color_identity()
kp |>
filter(conf == "ACC") |>
inner_join(teams_colors, by = c("team" = "kp_team")) |>
ggplot(aes(off_rtg, def_rtg)) +
geom_point(aes(col = color), shape = "square", size = 5) +
ggrepel::geom_text_repel(aes(label = team), size = 3, max.overlaps = 30) +
scale_color_identity()
get_kenpom_data = function() {
url = "https://kenpom.com/"
tbl = read_html(url) |>
html_nodes("table")
df = tbl[[1]] |>
html_table(fill = T)
kenpom_colnames = c(
"rank", "team", "conf", "record",
"net_rtg", "off_rtg", "off_rtg_rank", "def_rtg", "def_rtg_rank",
"adj_t", "adj_t_rank", "luck", "luck_rank",
"sos_net_rtg", "sos_net_rtg_rank",
"sos_off_rtg", "sos_off_rtg_rank",
"sos_def_rtg", "sos_def_rtg_rank",
"nc_sos_net_rtg", "nc_sos_net_rtg_rank"
)
df = df[-1, ] |>
setNames(kenpom_colnames) |>
filter(rank != "" & rank != "Rk") |>
separate(record, into = c("wins", "losses"), sep = "-", remove = F, convert = T) |>
mutate(gp = wins + losses, .before = "record") |>
mutate(win_pct = round(wins / gp, 3), .after = "losses") |>
mutate(rank = as.integer(rank),
net_rtg = as.double(net_rtg),
off_rtg = as.double(off_rtg),
off_rtg_rank = as.integer(off_rtg_rank),
def_rtg = as.double(def_rtg),
def_rtg_rank = as.integer(def_rtg_rank),
adj_t = as.double(adj_t),
adj_t_rank = as.integer(adj_t_rank),
luck = as.double(luck),
luck_rank = as.integer(luck_rank),
sos_net_rtg = as.double(sos_net_rtg),
sos_net_rtg_rank = as.integer(sos_net_rtg_rank),
sos_off_rtg = as.double(sos_off_rtg),
sos_off_rtg_rank = as.integer(sos_off_rtg_rank),
sos_def_rtg = as.double(sos_def_rtg),
sos_def_rtg_rank = as.integer(sos_def_rtg_rank),
nc_sos_net_rtg = as.double(nc_sos_net_rtg),
nc_sos_net_rtg_rank = as.integer(nc_sos_net_rtg_rank))
return(df)
}
kp = get_kenpom_data()
teams_colors = cbd_teams() |>
distinct(team = kp_team, color)
cbbdata::cbd_torvik_game_box()
cbbdata::cbd_torvik_game_box(year = 2024)
cbbdata::cbd_torvik_game_box(year = 2025)
cbbdata::cbd_torvik_game_box(year = 2026)
cbbdata::cbd_torvik_game_box(year = c(2025, 2026))
cbbdata::cbd_torvik_game_box(year = 2025)
cbbdata::cbd_torvik_game_box(year = 2025:2026)
cbbdata::cbd_torvik_game_box(year = 2025)
cbbdata::cbd_torvik_game_box(year = 2024)
cbbdata::cbd_torvik_game_box(year = 2025)
rbind(cbd_torvik_game_box(year = 2025), cbd_torvik_game_box(year = 2026))
rbind(cbd_torvik_game_box(year = 2025), cbd_torvik_game_box(year = 2026), ignore.attr = T)
rbind(
cbd_torvik_game_box(year = 2025),
cbd_torvik_game_box(year = 2026),
ignore.attr = T
)
tibble(rbind(
cbd_torvik_game_box(year = 2025),
cbd_torvik_game_box(year = 2026),
ignore.attr = T
))
tibble(rbind(
cbd_torvik_game_box(year = 2025),
cbd_torvik_game_box(year = 2026),
ignore.attr = T
)) |>
filter(date >= as_date("2025-08-31"))
cbbdata::cbd_match_teams()
?cbbdata::cbd_match_teams()
?cbbdata::cbd_match_teams(c("UNC"))
cbbdata::cbd_match_teams(c("UNC"))
cbbdata::cbd_match_teams()["UNC"]
cbbdata::cbd_match_teams(["UNC"])
cbbdata::cbd_match_teams(["UNC"])
cbbdata::cbd_match_teams("UNC")
try(cbd_match_teams()['Duke Blue Devils'])
cbbdata::cbd_torvik_season_schedule()
cbbdata::cbd_torvik_season_schedule(year = 2025)
cbbdata::cbd_torvik_season_schedule(year = 2026)
cbbdata::cbd_torvik_season_schedule(year = 2025)
cbbdata::cbd_torvik_game_box(year = 2025)
cbbdata::cbd_torvik_game_box(year = 2025) |>
arrange(desc(date))
cbbdata::cbd_torvik_game_box(year = 2026)
