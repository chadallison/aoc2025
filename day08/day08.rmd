---
title: "day08"
output: html_document
---

```{r message = F, warning = F}
tictoc::tic()

library(tidyverse)
library(glue)

input = readLines("input.txt")

df = tibble(raw = input) |>
  separate(raw, into = c("x", "y", "z"), sep = ",", convert = T, remove = T)

# build all pairwise connections
df1 = df |>
  mutate(id = row_number())

df2 = df |>
  mutate(id2 = row_number()) |>
  rename(x2 = x, y2 = y, z2 = z)

pairs = df1 |>
  crossing(df2) |>
  filter(id < id2) |>
  mutate(dist = sqrt((x - x2) ^ 2 + (y - y2) ^ 2 + (z - z2) ^ 2)) |>
  arrange(dist) |>
  slice(1:1000) |>
  select(id, id2)

# union find setup
n = nrow(df)
parent = seq_len(n)
size = rep(1, n)

find = function(a) {
  while (parent[a] != a) {
    parent[a] = parent[parent[a]]
    a = parent[a]
  }
  a
}

union = function(a, b) {
  ra = find(a)
  rb = find(b)
  if (ra == rb) return()
  if (size[ra] < size[rb]) {
    parent[ra] <<- rb
    size[rb] <<- size[rb] + size[ra]
  } else {
    parent[rb] <<- ra
    size[ra] <<- size[ra] + size[rb]
  }
}

walk2(pairs$id, pairs$id2, union)
final_sizes = size[unique(map_int(seq_len(n), find))]
sol = prod(sort(final_sizes, decreasing = T)[1:3])
as.character(glue("Part 1 solution: {sol}"))

pts = df |>
  mutate(id = row_number())

n = nrow(pts)
# 1. compute pairwise distance matrix
dmat = as.matrix(dist(pts |> select(x, y, z)))

# 2. build edge list from upper triangle
edge_idx = which(upper.tri(dmat), arr.ind = T)

edges = tibble(i = edge_idx[, 1],
               j = edge_idx[, 2],
               dist = dmat[edge_idx]) |>
  arrange(dist)

# 3. union-find setup
parent = seq_len(n)
size = rep(1, n)

find = function(a) {
  while (parent[a] != a) {
    parent[a] = parent[parent[a]]
    a = parent[a]
  }
  a
}

union = function(a, b) {
  ra = find(a)
  rb = find(b)
  if (ra == rb) return(F)

  if (size[ra] < size[rb]) {
    parent[ra] <<- rb
    size[rb] <<- size[rb] + size[ra]
  } else {
    parent[rb] <<- ra
    size[ra] <<- size[ra] + size[rb]
  }
  T
}

# 4. Kruskal loop: connect all junction boxes
components = n
last_i = NA
last_j = NA

for (k in seq_len(nrow(edges))) {
  a = edges$i[k]
  b = edges$j[k]

  if (union(a, b)) {
    components = components - 1
    last_i = a
    last_j = b

    if (components == 1) break
  }
}

# 5. multiply X coordinates as numeric to avoid integer overflow
sol = as.numeric(pts$x[last_i]) * as.numeric(pts$x[last_j])
as.character(glue("Part 2 solution: {sol}"))

tictoc::toc()
```













