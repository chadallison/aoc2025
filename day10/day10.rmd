---
title: "day10"
output: html_document
---

```{r message = F, warning = F}
library(tidyverse)
library(lpSolve)

to_vec = function(s) {
  str_split(s, "")[[1]] |>
    map_dbl(~ ifelse(.x == "#", 1, 0))
}

parse_buttons = function(x) {
  x |>
    str_extract_all("\\(([^)]*)\\)") |>
    unlist() |>
    str_remove_all("[()]") |>
    map(~ as.numeric(str_split(.x, ",")[[1]]))
}

build_matrix = function(buttons, n) {
  m = matrix(0, nrow = n, ncol = length(buttons))
  for (j in seq_along(buttons)) {
    idx = buttons[[j]] + 1
    m[idx, j] = 1
  }
  m
}

gf2_nullspace = function(A) {
  A = A %% 2
  m = nrow(A)
  n = ncol(A)

  R = A
  pivots = rep(0, m)
  row = 1

  for (col in 1:n) {
    pivot_row = which(R[row:m, col] == 1)[1]
    if (!is.na(pivot_row)) {
      pivot_row = pivot_row + row - 1
      if (pivot_row != row) {
        tmp = R[row, ]
        R[row, ] = R[pivot_row, ]
        R[pivot_row, ] = tmp
      }
      pivots[row] = col
      for (r in seq_len(m)) {
        if (r != row && R[r, col] == 1) {
          R[r, ] = (R[r, ] + R[row, ]) %% 2
        }
      }
      row = row + 1
      if (row > m) break
    }
  }

  free_cols = setdiff(1:n, pivots)
  if (length(free_cols) == 0) {
    return(matrix(0, nrow = n, ncol = 0))
  }

  basis = matrix(0, nrow = n, ncol = length(free_cols))
  col_idx = 1

  for (fc in free_cols) {
    v = rep(0, n)
    v[fc] = 1
    for (i in seq_along(pivots)) {
      pc = pivots[i]
      if (pc != 0 && R[i, fc] == 1) {
        v[pc] = 1
      }
    }
    basis[, col_idx] = v %% 2
    col_idx = col_idx + 1
  }

  basis
}

solve_gf2 = function(A, b) {
  m = nrow(A)
  n = ncol(A)
  Ab = cbind(A %% 2, b %% 2)

  R = Ab
  pivots = rep(0, m)
  row = 1

  for (col in 1:n) {
    pivot_row = which(R[row:m, col] == 1)[1]
    if (!is.na(pivot_row)) {
      pivot_row = pivot_row + row - 1
      if (pivot_row != row) {
        tmp = R[row, ]
        R[row, ] = R[pivot_row, ]
        R[pivot_row, ] = tmp
      }
      pivots[row] = col
      for (r in seq_len(m)) {
        if (r != row && R[r, col] == 1) {
          R[r, ] = (R[r, ] + R[row, ]) %% 2
        }
      }
      row = row + 1
      if (row > m) break
    }
  }

  for (i in seq_len(m)) {
    if (all(R[i, 1:n] == 0) && R[i, n + 1] == 1) {
      return(NULL)
    }
  }

  x0 = rep(0, n)
  for (i in seq_along(pivots)) {
    pc = pivots[i]
    if (pc != 0) {
      x0[pc] = R[i, n + 1]
    }
  }

  N = gf2_nullspace(A)

  if (ncol(N) == 0) {
    return(matrix(x0, ncol = 1))
  }

  k = ncol(N)
  combos = 2^k
  out = matrix(0, nrow = n, ncol = combos)

  for (mask in 0:(combos - 1)) {
    bits = as.integer(intToBits(mask))[1:k]
    vec = x0
    for (j in seq_len(k)) {
      if (bits[j] == 1) vec = (vec + N[, j]) %% 2
    }
    out[, mask + 1] = vec
  }

  out
}

fewest_presses = function(line) {
  diag = str_extract(line, "\\[[^]]*\\]") |>
    str_remove_all("[\\[\\]]")
  target = to_vec(diag)

  buttons = parse_buttons(line)
  A = build_matrix(buttons, length(target))

  sols = solve_gf2(A, target)
  if (is.null(sols)) return(Inf)

  apply(sols, 2, sum) |> min()
}

# At the end, after reading input:

input = readLines("input.txt")
sol = sum(map_dbl(input, fewest_presses))
as.character(glue("Part 1 solution: {sol}"))
```

```{r}
fewest_presses_part2 = function(line) {
  buttons = parse_buttons(line)
  target = parse_targets(line)

  A = build_matrix(buttons, length(target))
  n_buttons = ncol(A)

  obj = rep(1, n_buttons)

  sol = lp(
    direction = "min",
    objective.in = obj,
    const.mat = A,
    const.dir = rep("=", length(target)),
    const.rhs = target,
    all.int = TRUE
  )

  if (sol$status != 0) {
    return(Inf)
  }

  sol$objval
}

input = readLines("input.txt")
total2 = sum(map_dbl(input, fewest_presses_part2))
print(total2)

```

```{r}

```

